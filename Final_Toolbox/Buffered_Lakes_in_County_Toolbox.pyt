# ####### FINAL TOOLBOX# This tool will allow you to buffer the lakes in a county of your choosing, to a buffer# distance of your choosing.# It will also execute functions such as checking coordinate systems, counting features, and# describing features along the way.# It will provide messages to let you know you are on the right track and that# outputs have been created successfully.# STEP 1# As always, I input arcpy, enable overwriteimport arcpyarcpy.env.overwriteOutput = True# STEP 2: DEFINING MY TOOLBOX# This toolbox (Bella's Final Toolbox) has 4 tools -# Select, Clip, Buffer, and AddMessageclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Bella's Final Toolbox"        self.alias = ""        # List of tool classes associated with this toolbox        self.tools = [Select, Clip, Buffer, AddMessage]# STEP 3: Tool 1- Select# This tool uses the Towns shapefile and selects only the polygons# of the county of your choosing.# Inputs are - Input Towns file and County Name.# The output will be a shapefile showing only the towns in the county you chose.class Select(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "1. Selecting County"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = []        input_towns = arcpy.Parameter(name="input_towns",                                      displayName="Input Towns Shapefile",                                      datatype="DEFeatureClass",                                      parameterType="Required",                                      direction="Input",                                      )        params.append(input_towns)        county_name = arcpy.Parameter(name="county_name",                                      displayName="County Name",                                      datatype="GPString",                                      parameterType="Required",                                      direction="Input",                                      )        params.append(county_name)        output_select = arcpy.Parameter(name="output_select",                                        displayName="Output",                                        datatype="DEFeatureClass",                                        parameterType="Required",                                        direction="Output",                                        )        params.append(output_select)        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_towns = parameters[0].valueAsText        county_name = parameters[1].valueAsText        output = parameters[2].valueAsText        arcpy.Select_analysis(in_features=input_towns, out_feature_class=output,                              where_clause="COUNTY = '{}'".format(county_name))        if arcpy.Exists(output):            arcpy.AddMessage(county_name + " County Successfully Selected.")        else:            arcpy.AddMessage(county_name + " could not be selected.")        return# STEP 4: Tool 2- Clip# This tool will clip the lakes to the county extent you chose.# The tool requires 2 inputs - lakes and the county from the previous tool.# The output is a shapefile containing the lakes in the county.# The tool will also check the coordinate systems of the two datasets and# add a message stating if the coordinate systems match or not.# The tool only selects the lakes that are larger than 1 acre, using# arcpy.MakeFeatureLayer.# Finally, the tool will use arcpy.GetCount to let you know how many# lakes there are in your county.class Clip(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "2. Clipping lakes to County"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = []        input_lakes = arcpy.Parameter(name="input_lakes",                                      displayName="Input Lakes",                                      datatype="DEFeatureClass",                                      parameterType="Required",  # Required|Optional|Derived                                      direction="Input",  # Input|Output                                      )        params.append(input_lakes)        input_county = arcpy.Parameter(name="input_county",                                       displayName="Input County (Output from Select Tool)",                                       datatype="DEFeatureClass",                                       parameterType="Required",  # Required|Optional|Derived                                       direction="Input",  # Input|Output                                       )        params.append(input_county)        output = arcpy.Parameter(name="output",                                 displayName="Output",                                 datatype="DEFeatureClass",                                 parameterType="Required",  # Required|Optional|Derived                                 direction="Output",  # Input|Output                                 )        params.append(output)        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_lakes = parameters[0].valueAsText        input_county = parameters[1].valueAsText        output = parameters[2].valueAsText        # Describing coordinate systems, seeing if they match.        input_lakes_desc = arcpy.Describe(input_lakes)        lakes_coordinates = input_lakes_desc.spatialReference.name        input_county_desc = arcpy.Describe(input_county)        county_coordinates = input_county_desc.spatialReference.name        if county_coordinates != lakes_coordinates:            arcpy.AddMessage("Coordinate Systems do not match.")        else:            arcpy.AddMessage("Coordinate Systems match.")        # Selecting only the lakes that are larger than 1 acre.        arcpy.MakeFeatureLayer_management(input_lakes, "large_lakes", where_clause="Acres >= 1")        if arcpy.Exists("large_lakes"):            arcpy.AddMessage("Selecting Lakes >1 acre")        else:            arcpy.AddMessage("Could not select Lakes > 1 acre")        # Executing Clip        arcpy.Clip_analysis(in_features="large_lakes",                            clip_features=input_county,                            out_feature_class=output)        arcpy.AddMessage("Clip  completed successfully.")        # Counting lakes in county        lakes_county = arcpy.GetCount_management(output)        count = int(lakes_county.getOutput(0))        arcpy.AddMessage("There are {} lakes in the county.".format(count))        return# STEP 5: Tool 3- Buffer# This tool buffers the Lakes of Washington County shapefile to your desired feet.# The tool will require 2 inputs - the clipped lake shaepfile just generated,# and the buffer distance (in feet).# The resulting shapefile will show you the lakes (greater than 1 acre) in your county,# buffered to the distance of your choosing.# Finally, the arcpy.Describe tool will let you know features of your output file, including# coordinate system, name,class Buffer(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "3. Buffering lakes"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = []        input_lakes = arcpy.Parameter(name="input_lakes",                                      displayName="Input Lakes, Clipped to County (Output from Clip Tool)",                                      datatype="DEFeatureClass",                                      parameterType="Required",                                      direction="Input",                                      )        params.append(input_lakes)        buffer_distance = arcpy.Parameter(name="buffer_distance",                                          displayName="Buffer Distance (in feet)",                                          datatype="GPLong", parameterType="Required",                                          direction="Input",                                          )        params.append(buffer_distance)        output = arcpy.Parameter(name="output",                                 displayName="Output",                                 datatype="DEFeatureClass",                                 parameterType="Required",  # Required|Optional|Derived                                 direction="Output",  # Input|Output                                 )        params.append(output)        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_lakes = parameters[0].valueAsText        buffer_distance = parameters[1].valueAsText        output_buffer = parameters[2].valueAsText        arcpy.Buffer_analysis(in_features=input_lakes,                              out_feature_class=output_buffer,                              buffer_distance_or_field="{} Feet".format(buffer_distance))        if arcpy.Exists(output_buffer):            arcpy.AddMessage("Lakes Successfully Buffered.")        desc = arcpy.Describe(output_buffer)        arcpy.AddMessage("Description of the buffered dataset:")        arcpy.AddMessage("Name: {}".format(desc.name))        arcpy.AddMessage("Feature Type: {}".format(desc.shapeType))        arcpy.AddMessage("Coordinate System: {}".format(desc.spatialReference.name))        return# STEP 5: Tool 4- AddMessasge# This last tool asks if I slayed the final.# Hopefully I did, in fact, slay the final; otherwise this is awkward...# This class takes an input string as its only parameter.class AddMessage(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "4. Assessing Slay"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        params = []        input_string = arcpy.Parameter(name="input_string",                                       displayName="DID I SLAY THIS FINAL :) ????",                                       parameterType="Required",                                       direction="Input",                                       )        params.append(input_string)        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_string = parameters[0].valueAsText        arcpy.AddMessage("DID I SLAY THIS FINAL :) ???? " + str(input_string))        return